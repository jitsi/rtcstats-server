const assert = require('assert').strict;
const fs = require('fs');

const logger = require('../../logging'); // Assuming you have a logger module
const { clearObjectUndefinedValues, waitForCheck } = require('../jest/test-utils');

/**
 * Represents a mock implementation of a Firehose connector.
 */
class FirehoseConnectorMock {
    /**
     * Creates a new instance of FirehoseConnectorMock.
     * @constructor
     *
     * @param {boolean} enableResultsFile - Whether to enable writing results to a file.
     * @param {string} resultsDir - The directory to write results to.
     * @param {number} timeoutSec - How much we should wait for the test to complete.
     */
    constructor(enableResultsFile = false, resultsDir, timeoutSec = 10) {
        // Mock implementation of constructor
        logger.debug('[Firehose] Created a new FirehoseConnectorMock instance.');

        this.meetingMap = {};
        this.pcMap = {};
        this.trackMap = {};
        this.timeoutSec = timeoutSec;

        // The expected results data cand be quite verbose, at times it's useful to write it to a file
        // so that we can compare it with the actual results.
        this.resultsFile = `${resultsDir}/results.json`;
        this.pcResultsFile = `${resultsDir}/results-pc.json`;
        this.trackResultsFile = `${resultsDir}/results-track.json`;
        this.enableResultsFile = enableResultsFile;

        fs.existsSync(this.resultsFile) && fs.rmSync(this.resultsFile);
        fs.existsSync(this.pcResultsFile) && fs.rmSync(this.pcResultsFile);
        fs.existsSync(this.trackResultsFile) && fs.rmSync(this.trackResultsFile);
    }

    /**
     * Connects to the Firehose.
     */
    connect() {
        // Mock implementation of connect
        logger.debug('[Firehose] Successfully connected.');
    }

    /**
     * Write the received data entry to the results file,
     * for comparison with the expected results.
     *
     * @param {Object} objectToWrite - The object to write to the file.
     * @param {string} filePath - The path to the file to write to.
     */
    _writeResultsToFile(objectToWrite, filePath) {
        if (!this.enableResultsFile) {
            return;
        }

        fs.appendFile(filePath, `${JSON.stringify(objectToWrite, null, 2)}\n`, err => {
            if (err) {
                throw err;
            }
        });
    }

    /**
     * Writes a peer connections aggregated stats to the result file.
     *
     * @param {Object} pcObjectToWrite - The PC object to write.
     */
    _writePCResultsToFile(pcObjectToWrite) {
        // We write the PC object to the file, with the PC name as the key.
        this._writeResultsToFile({
            [pcObjectToWrite.pcname]: pcObjectToWrite
        }, this.pcResultsFile);
    }

    /**
     * Writes a track stats entry to the result file.
     *
     * @param {Object} trackObjectToWrite - The track object to write.
     */
    _writeTrackResultsToFile(trackObjectToWrite) {
        const trackIdentifier = this._getTrackIdentifier(trackObjectToWrite);

        // We write the track object to the file, with the track identifier as the key.
        this._writeResultsToFile({
            [trackIdentifier]: trackObjectToWrite
        }, this.trackResultsFile);
    }

    /**
     * Returns the track identifier.
     * @param {Object} params - The parameters for generating the track identifier.
     * @param {string} params.trackSSRC - The SSRC of the track.
     * @param {string} params.direction - The direction of the track.
     *
     * @returns {string} - The track identifier.
     */
    _getTrackIdentifier({ ssrc, direction }) {
        // inbound-rtp and outbound-rtp tracks have equivalent remote-inbound-rtp and remote-outbound-rtp tracks
        // with the same SSRC, so we need to differentiate them by the direction.
        return `${ssrc}-${direction}`;
    }

    /**
     * Loads a test entry to be used for comparison with the actual results.
     * the test entries are loaded from predefined results files.
     *
     * @param {string} statsSessionId - The stats session ID, generated by the mock client.
     * @param {Object} expectedRedshiftData - The expected Redshift data.
     */
    loadTestEntry(statsSessionId, expectedRedshiftData) {
        logger.debug('[Firehose Mock] Loading entry: %o', expectedRedshiftData);

        const { meetingRecord = {}, pcRecords = {}, trackRecords = {} } = expectedRedshiftData;

        // Skip if the expected data is empty, this indicates that this particular test has 
        // no firehose entries to send.
        if (Object.keys(meetingRecord).length === 0) {
            return;
        }

        // statsSessionId and createDate are dynamic fields we can't expect
        // deterministic values for, so we hardcode them.
        this.meetingMap[statsSessionId] = meetingRecord;
        this.meetingMap[statsSessionId].statsSessionId = statsSessionId;

        // load the PC and track records, statsSessionId being dynamic we hardcode it.
        // the test will expected all these entries to be cleared by in a certain time interval.
        // if they are not cleared, the test will fail. This simulates all the expected entries
        // being sent to firehose/redshift.
        Object.entries(pcRecords).map(([ pcName, pcRecord ]) => {
            this.pcMap[pcName] = pcRecord;
            this.pcMap[pcName].statsSessionId = statsSessionId;
        });

        Object.entries(trackRecords).map(([ trackIdentifier, trackRecord ]) => {

            // TODO currently remote-inbound-rtp and remote-outbound-rtp are treated as
            // a receiver track and a sender track respectively, this needs to be rethought
            // with separate stat track types.
            this.trackMap[trackIdentifier] = trackRecord;
            this.trackMap[trackIdentifier].statsSessionId = statsSessionId;
        });
    }

    /**
     * Mock interface for sending a track's aggregate features.
     *
     * @param {Object} trackFeaturesRecord - The track features record.
     */
    putTrackFeaturesRecord(trackFeaturesRecord) {
        // Mock implementation of putTrackFeaturesRecord
        logger.debug('Putting track features record:', trackFeaturesRecord);

        // createDate, id and pcId are dynamic fields we can't expect.
        trackFeaturesRecord.createDate = '';
        trackFeaturesRecord.id = '';
        trackFeaturesRecord.pcId = '';

        this._writeTrackResultsToFile(trackFeaturesRecord);

        const trackIdentifier = this._getTrackIdentifier(trackFeaturesRecord);

        // Remove undefined fields from the record
        const trackFeaturesRecordNoUndef = clearObjectUndefinedValues(trackFeaturesRecord);

        !this.enableResultsFile && assert.deepEqual(trackFeaturesRecordNoUndef, this.trackMap[trackIdentifier]);

        delete this.trackMap[trackIdentifier];
    }

    /**
     * Mock interface for sending a pc's aggregate features.
     *
     * @param {Object} pcFeaturesRecord - The PC features record.
     */
    putPCFeaturesRecord(pcFeaturesRecord) {
        // Mock implementation of putPCFeaturesRecord
        logger.debug('Putting PC features record:', pcFeaturesRecord);

        // createDate and id are dynamic fields we can't expect.
        pcFeaturesRecord.createDate = '';
        pcFeaturesRecord.id = '';

        this._writePCResultsToFile(pcFeaturesRecord);

        const { pcname } = pcFeaturesRecord;

        // Remove undefined fields from the record
        const pcFeaturesRecordNoUndef = clearObjectUndefinedValues(pcFeaturesRecord);

        !this.enableResultsFile && assert.deepEqual(pcFeaturesRecordNoUndef, this.pcMap[pcname]);

        delete this.pcMap[pcname];
    }

    /**
     * Mock interface for sending a meeting's aggregate features.
     *
     * @param {Object} meetingFeaturesRecord - The meeting features record.
     */
    putMeetingFeaturesRecord(meetingFeaturesRecord) {
        // Mock implementation of putMeetingFeaturesRecord
        logger.debug('Putting meeting features record:', meetingFeaturesRecord);

        meetingFeaturesRecord.createDate = '';

        this._writeResultsToFile(meetingFeaturesRecord, this.resultsFile);

        const { statsSessionId } = meetingFeaturesRecord;

        // Remove undefined fields from the record
        const meetingFeaturesRecordNoUndef = clearObjectUndefinedValues(meetingFeaturesRecord);

        !this.enableResultsFile && assert.deepEqual(meetingFeaturesRecordNoUndef, this.meetingMap[statsSessionId]);

        delete this.meetingMap[statsSessionId];
    }

    /**
     * Mock implementation of putFaceLandmarkRecords
     *
     * @param {Object[]} faceLandmarkRecords - The array of face landmark records.
     */
    putFaceLandmarkRecords(faceLandmarkRecords) {
        logger.debug('Putting face landmark records:', faceLandmarkRecords);
    }

    /**
     * Mock implementation of putMeetingEventRecords
     *
     * @param {Object[]} meetingEventRecords - The array of meeting event records.
     */
    putMeetingEventRecords(meetingEventRecords) {
        logger.debug('Putting meeting event records:', meetingEventRecords);
    }

    /**
     * Waits for the test to complete for the preset timeout.
     * Checks every second if all the test entries have been processed.
     * Entries are removed from the maps when they are processed and have the expected results,
     * so when the maps are empty, we considered that all the entries have been processed and
     * complete the test.
     *
     * @returns {Promise} - A promise that resolves when the test is complete.
     * @throws {Error} - If the test does not complete within the preset timeout.
     */
    async waitForTestCompletion() {
        return await waitForCheck(this.timeoutSec, this._isTestCompleted.bind(this));
    }

    /**
     * Checks if the test is completed.
     * The test is considered completed when all the entries have been processed and have the expected results.
     * @returns {boolean} - True if the test is completed, false otherwise.
     */
    _isTestCompleted() {
        return (
            Object.keys(this.meetingMap).length === 0
            && Object.keys(this.pcMap).length === 0
            && Object.keys(this.trackMap).length === 0
        );
    }
}

module.exports = FirehoseConnectorMock;
