const assert = require('assert').strict;
const fs = require('fs');

const logger = require('../../logging');
const { waitForCheck } = require('../jest/test-utils');

/**
 * Class representing a DynamoDataSenderMock.
 */
class DynamoDataSenderMock {
    /**
     * Represents a DynamoDataSenderMock object that is responsible for sending data to DynamoDB.
     * @constructor
     *
     * @param {boolean} enableResultsFile - Whether to enable writing results to a file.
     * @param {string} resultsDir - The directory to write results to.
     * @param {number} timeoutSec - How much we should wait for the test to complete.
     */
    constructor(enableResultsFile = false, resultsDir, timeoutSec = 10) {
        this.entryMap = {};
        this.enableResultsFile = enableResultsFile;
        this.resultsFile = `${resultsDir}/dynamo-results.json`;
        this.timeoutSec = timeoutSec;

        fs.existsSync(this.resultsFile) && fs.rmSync(this.resultsFile);
    }


    /**
     * Write the received dynamo entry to the results file,
     * for comparison with the expected results.
     *
     * @param {Object} objectToWrite - The object to write to the file.
     * @param {string} filePath - The path to the file to write to.
     */
    _writeResultsToFile(objectToWrite) {
        if (!this.enableResultsFile) {
            return;
        }

        fs.appendFile(this.resultsFile, `${JSON.stringify(objectToWrite, null, 2)}\n`, err => {
            if (err) {
                throw err;
            }
        });
    }

    /**
     * Mock implementation of saveEntry
     *
     * @param {Object} entry - The entry to save.
     * @returns {Promise} - A promise that resolves when the entry is saved.
     */
    async saveEntry(entry) {
        logger.debug('[Dynamo Mock] Saving entry: %o', entry);

        const baseDumpId = entry.baseDumpId;
        const expectedEntry = this.entryMap[baseDumpId];

        this._writeResultsToFile(entry);

        !this.enableResultsFile && assert.deepStrictEqual(entry, expectedEntry);

        delete this.entryMap[baseDumpId];

        return true;
    }

    /**
     * Loads a test entry to be used for comparison with the actual results.
     * the test entries are loaded from predefined results files.
     *
     * @param {string} baseDumpId - The stats session ID, generated by the mock client.
     * @param {Object} expectedDynamoData - The expected DynamoDB entry to load.
     */
    loadTestEntry(baseDumpId, expectedDynamoData) {
        logger.debug('[Dynamo Mock] Loading entry: %o', baseDumpId);

        expectedDynamoData.baseDumpId = baseDumpId;
        expectedDynamoData.dumpId = `${baseDumpId}.gz`;

        this.entryMap[baseDumpId] = expectedDynamoData;
    }

    /**
     * Waits for the test to complete for the preset timeout.
     * Checks every second if all the test entries have been processed.
     * Entries are removed from the maps when they are processed and have the expected results,
     * so when the maps are empty, we considered that all the entries have been processed and
     * complete the test.
     *
     * @returns {Promise} - A promise that resolves when the test is complete.
     * @throws {Error} - If the test does not complete within the preset timeout.
     */
    async waitForTestCompletion() {
        return await waitForCheck(this.timeoutSec, this._isTestCompleted.bind(this));
    }

    /**
     * Checks if the test is completed.
     * The test is considered completed when all the entries have been processed and have the expected results.
     * @returns {boolean} - True if the test is completed, false otherwise.
     */
    _isTestCompleted() {
        return Object.keys(this.entryMap).length === 0;
    }
}

module.exports = DynamoDataSenderMock;
