/* eslint-disable no-invalid-this */
/* eslint-disable no-multi-str */
const assert = require('assert').strict;
const { EventEmitter } = require('events');
const fs = require('fs');
const LineByLine = require('line-by-line');
const WebSocket = require('ws');

const server = require('../RTCStatsServer');
const FeaturesPublisher = require('../database/FeaturesPublisher');
const logger = require('../logging');
const MetadataStorageHandler = require('../store/MetadataStorageHandler');
const { ClientType } = require('../utils/ConnectionInformation');
const { uuidV4, ResponseType, exitAfterLogFlush } = require('../utils/utils');

const OrphanDumpsSimulator = require('./OrphanDumpsSimulator');
const DynamoDataSenderMock = require('./mock/DynamoDataSenderMock');
const FirehoseConnectorMock = require('./mock/FirehoseConnectorMock');

let testCheckRouter;

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'; // ignore self-signed cert

const BrowserUASamples = Object.freeze({
    CHROME:
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko)'
        + ' Chrome/87.0.4280.27 Safari/537.36',
    CHROME96: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 '
        + '(KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36',
    FIREFOX: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0',
    SAFARI:
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko)'
        + ' Version/14.0 Safari/605.1.15',
    NODE: 'Node v16.20.0'
});

const ProtocolV = Object.freeze({
    LEGACY: '3.1_LEGACY',
    STANDARD: '3.1_STANDARD',
    JVB: '3.0_JVB',
    JICOFO: '1.0_JICOFO',
    JIGASI: '1.0_JIGASI'
});

/**
 *
 */
class RTCStatsConnection extends EventEmitter {
    /**
     *
     * @param {*} param0
     */
    constructor({ id, serverUrl, dumpPath, readDelay = 1000, wsOptions, protocolV }) {
        super();
        this.id = id;
        this.dumpPath = dumpPath;
        this.serverUrl = serverUrl;
        this.wsOptions = wsOptions;
        this.readDelay = readDelay;
        this.protocolV = protocolV;
        this.statsSessionId = uuidV4();

        if (protocolV === ProtocolV.STANDARD) {
            this._processLine = this._processStandardLine;
        } else {
            this._processLine = this._processBackendServiceLine;
        }
    }

    /**
     *
     */
    getStatsSessionId() {
        return this.statsSessionId;
    }

    /**
     *
     */
    connect() {
        this.startWSOpen = new Date();
        this.ws = new WebSocket(this.serverUrl, this.protocolV, this.wsOptions);
        this.ws.on('open', this._open);
        this.ws.on('close', this._close);
        this.ws.on('error', this._error);
    }

    /**
     *
     */
    _sendIdentity(identity) {
        const identityRequest = {
            statsSessionId: this.statsSessionId,
            type: 'identity',
            data: identity
        };

        this._sendRequest(identityRequest);
    }

    /**
     *
     * @param {*} data
     */
    _sendStats(data) {
        const statsRequest = {
            statsSessionId: this.statsSessionId,
            type: 'stats-entry',
            data
        };

        this._sendRequest(statsRequest);
    }

    /**
     *
     * @param {*} request
     */
    _sendRequest(request) {
        this.ws.send(JSON.stringify(request));
    }

    /**
     * Process a line from a jvb dump file.
     * @param {string} line - The line to process.
     * @returns {void}
     */
    _processBackendServiceLine(line) {
        const parsedDumpEntry = JSON.parse(line);

        parsedDumpEntry.statsSessionId = this.statsSessionId;

        this._sendRequest(parsedDumpEntry);
    }

    /**
     * Process a line from a standard dump file.
     * @param {string} line - The line to process.
     * @returns {void}
     */
    _processStandardLine(line) {
        const parsedLine = JSON.parse(line);
        const [ entryType ] = parsedLine;

        switch (entryType) {
        case 'identity':
            this._sendIdentity(parsedLine);
            break;
        case 'connectionInfo':
            // Do nothing, connection info is generated by the server on first request.
            break;
        default:
            this._sendStats(line);
        }
    }

    /**
     *
     */
    _open = () => {
        const endWSOpen = new Date() - this.startWSOpen;

        logger.info(`Connected ws ${this.id} setup time ${endWSOpen}`);

        this.lineReader = new LineByLine(this.dumpPath);

        this.lineReader.on('line', line => {
            this._processLine(line);
        });

        this.lineReader.on('end', () => {
            this.ws.close();
        });

        this.lineReader.on('error', err => {
            logger.error('LineReader error:', err);
            this.ws.close();
        });
    };

    _close = () => {
        const closedAfter = new Date() - this.startWSOpen;

        logger.info(`Closed ws ${this.id} in ${closedAfter}`);
        this.emit('finished', { id: this.id });
    };

    _error = e => {
        const errorAfter = new Date() - this.startWSOpen;

        logger.info(`Failed ws ${this.id}, error %o in ${errorAfter}`, e);
        this.emit('finished', { id: this.id });
    };
}


/**
 *
 */
class TestCheckRouter {
    /**
     *
     * @param {*} appServer
     */
    constructor(appServer) {
        this.testCheckMap = {};

        appServer.workerPool.on(ResponseType.DONE, body => {
            this.routeDoneResponse(body);
        });

        appServer.workerPool.on(ResponseType.METRICS, body => {
            this.routeMetricsResponse(body);
        });

        appServer.workerPool.on(ResponseType.ERROR, body => {
            this.routeErrorResponse(body);
        });
    }

    /**
     *
     * @param {*} responseBody
     */
    checkResponseFormat(responseBody) {
        assert('clientId' in responseBody.dumpMetadata);
        assert(responseBody.dumpMetadata.clientId in this.testCheckMap);
    }

    /**
     *
     * @param {*} body
     */
    routeDoneResponse(body) {
        this.checkResponseFormat(body);
        this.testCheckMap[body.dumpMetadata.clientId].checkDoneResponse(body);
    }

    /**
     *
     * @param {*} body
     */
    routeErrorResponse(body) {
        this.checkResponseFormat(body);
        this.testCheckMap[body.dumpMetadata.clientId].checkErrorResponse(body);
    }

    /**
     *
     * @param {*} body
     */
    routeMetricsResponse(body) {
        this.checkResponseFormat(body);
        this.testCheckMap[body.dumpMetadata.clientId].checkMetricsResponse(body);
    }

    /**
     *
     * @param {*} testCheck
     */
    attachTest(testCheck) {
        // Make sure that the test object contains at least the statsSessionId key so we can route results to their
        // appropriate tests.
        assert('statsSessionId' in testCheck);

        this.testCheckMap[testCheck.statsSessionId] = testCheck;
    }
}

/**
 *
 * @param {*} dumpPath
 * @param {*} resultPath
 */
async function simulateConnection({ dumpPath,
    resultPath,
    dynamoDataSenderMock,
    firehoseConnectorMock,
    ua,
    protocolV }) {
    const resultString = fs.readFileSync(resultPath);
    const resultObject = JSON.parse(resultString);
    const { expectedDynamoData, expectedRedshiftData } = resultObject;
    const wsOptions = {
        headers: {
            'User-Agent': ua
        },
        origin: 'https://localhost'
    };

    const rtcstatsWsOptions = {
        id: dumpPath,
        serverUrl: 'ws://localhost:3000/',
        dumpPath,
        readDelay: 1,
        wsOptions,
        protocolV
    };

    const connection = new RTCStatsConnection(rtcstatsWsOptions);
    const statsSessionId = connection.getStatsSessionId();

    dynamoDataSenderMock.loadTestEntry(statsSessionId, expectedDynamoData);
    firehoseConnectorMock.loadTestEntry(statsSessionId, expectedRedshiftData);

    testCheckRouter.attachTest({
        statsSessionId,
        checkDoneResponse: body => {
            logger.debug(
                '[TEST] Handling DONE event with statsSessionId %j, body %o',
                body.dumpMetadata.clientId, body);

            const parsedBody = JSON.parse(JSON.stringify(body));
            const resultTemplate = resultObject.expectedExtractData;

            resultTemplate.dumpMetadata.clientId = statsSessionId;

            // The size of the dump changes with every iteration as the application will add an additional
            // 'connectionInfo' entry, thus metrics won't match.
            // Same cases applies to start and end date

            // Operations on parsedBody.dumpMetadata
            delete parsedBody.dumpMetadata.dumpPath;
            delete parsedBody.features?.metrics;

            // Operations on resultTemplate.dumpMetadata
            delete resultTemplate.dumpMetadata.dumpPath;
            delete resultTemplate.features?.metrics;

            if (parsedBody.dumpMetadata.clientType !== ClientType.RTCSTATS) {
                delete parsedBody.features.sessionStartTime;
                delete parsedBody.features.sessionEndTime;
            }

            // logger.info('Parsed body: %o', parsedBody);
            // logger.info('Result template: %o', resultTemplate);

            assert.deepStrictEqual(parsedBody, resultTemplate);
        },
        checkErrorResponse: body => {
            logger.info('[TEST] Handling ERROR event with body %o', body);
            throw Error(`[TEST] Processing failed with: ${JSON.stringify(body)}`);
        },
        checkMetricsResponse: body => {
            logger.info('[TEST] Handling METRICS event with body %j', body);

            // assert.fail(body.extractDurationMs < 400);
        }
    });

    connection.connect();
}

/**
 *
 */
async function runTest() {
    const enableResultFiles = false;

    // The mock firehose connector and dynamo data sender are used to simulate their
    // respective serivices. They are used to verify that the server is sending the
    // correct data to the correct services.
    const firehoseConnectorMock = new FirehoseConnectorMock(enableResultFiles);
    const featPublisher = new FeaturesPublisher(firehoseConnectorMock, 'local');

    const dynamoDataSenderMock = new DynamoDataSenderMock(enableResultFiles);
    const metadataStorageHandler = new MetadataStorageHandler(dynamoDataSenderMock);

    server.setServices(featPublisher, metadataStorageHandler);

    testCheckRouter = new TestCheckRouter(server);


    await simulateConnection({
        dumpPath: './src/test/dumps/jigasi-sample',
        resultPath: './src/test/integration-results/jigasi-sample-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.NODE,
        protocolV: ProtocolV.JIGASI
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();


    await simulateConnection({
        dumpPath: './src/test/dumps/jicofo-sample',
        resultPath: './src/test/integration-results/jicofo-sample-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.NODE,
        protocolV: ProtocolV.JICOFO
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    // We run each type of dump sequentially, and the mock services verify that the right
    // data in the right format is sent.
    await simulateConnection({
        dumpPath: './src/test/dumps/jvb-sample',
        resultPath: './src/test/integration-results/jvb-sample-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.NODE,
        protocolV: ProtocolV.JVB
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();


    // We run each type of dump sequentially, and the mock services verify that the right
    // data in the right format is sent.
    await simulateConnection({
        dumpPath: './src/test/dumps/google-standard-stats-p2p',
        resultPath: './src/test/integration-results/google-standard-stats-p2p-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.CHROME,
        protocolV: ProtocolV.STANDARD
    });

    // The mock services wait a specific time for each expected result to arrive.
    // If the data arrives in wrong format or not all the expected data arrives, the
    // waitFOrTestCompletion will throw an error after the timeout.
    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    await simulateConnection({
        dumpPath: './src/test/dumps/google-standard-stats-sfu',
        resultPath: './src/test/integration-results/google-standard-stats-sfu-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.CHROME,
        protocolV: ProtocolV.STANDARD
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    simulateConnection({
        dumpPath: './src/test/dumps/firefox-standard-stats-sfu',
        resultPath: './src/test/integration-results/firefox-standard-stats-sfu-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.FIREFOX,
        protocolV: ProtocolV.STANDARD
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    simulateConnection({
        dumpPath: './src/test/dumps/firefox97-standard-stats-sfu',
        resultPath: './src/test/integration-results/firefox97-standard-stats-sfu-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.FIREFOX,
        protocolV: ProtocolV.STANDARD
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    simulateConnection({
        dumpPath: './src/test/dumps/safari-standard-stats',
        resultPath: './src/test/integration-results/safari-standard-stats-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.SAFARI,
        protocolV: ProtocolV.STANDARD
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();

    simulateConnection({
        dumpPath: './src/test/dumps/chrome96-standard-stats-p2p-add-transceiver',
        resultPath: './src/test/integration-results/chrome96-standard-stats-p2p-add-transceiver-result.json',
        dynamoDataSenderMock,
        firehoseConnectorMock,
        ua: BrowserUASamples.CHROME96,
        protocolV: ProtocolV.STANDARD
    });

    await dynamoDataSenderMock.waitForTestCompletion();
    await firehoseConnectorMock.waitForTestCompletion();
}

process.on('uncaughtException', async err => {
    logger.error('[TEST] Integration test encountered an uncaught exception, exiting process with error: <%o>', err);
    await closeServerAndExit(1);
});

process.on('unhandledRejection', async reason => {
    logger.error('[TEST] Integration test encountered unhandled rejection, exiting process with error: %o', reason);
    await closeServerAndExit(1);
});

/**
 * Close the server and exit the process.
 *
 * @param {*} exitCode - The exit code to use when exiting the process.
 */
async function closeServerAndExit(exitCode = 0) {
    server.stop();
    await exitAfterLogFlush(logger, exitCode);
}

(async () => {
    try {
        const orphanDumpsSimulator = new OrphanDumpsSimulator(server);

        orphanDumpsSimulator.populateWithOrphanDumps();
        server.start();

        // Simple brute force test that makes sure the server processes orphaned dump files
        // after a restart.
        await orphanDumpsSimulator.waitForTestCompletion();

        // Run result based checks, makes sure that the right data is sent to the right service.
        await runTest();
        await closeServerAndExit();
    } catch (e) {
        logger.error('Error:', e);
        await closeServerAndExit(1);
    }
})();
